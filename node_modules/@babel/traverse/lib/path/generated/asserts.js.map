{"version":3,"names":[],"sources":["../../../src/path/generated/asserts.ts"],"sourcesContent":["/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport type * as t from \"@babel/types\";\nimport type NodePath from \"../index\";\n\nexport interface NodePathAssetions {\n  assertAccessor(opts?: object): asserts this is NodePath<t.Accessor>;\n  assertAnyTypeAnnotation(\n    opts?: object,\n  ): asserts this is NodePath<t.AnyTypeAnnotation>;\n  assertArgumentPlaceholder(\n    opts?: object,\n  ): asserts this is NodePath<t.ArgumentPlaceholder>;\n  assertArrayExpression(\n    opts?: object,\n  ): asserts this is NodePath<t.ArrayExpression>;\n  assertArrayPattern(opts?: object): asserts this is NodePath<t.ArrayPattern>;\n  assertArrayTypeAnnotation(\n    opts?: object,\n  ): asserts this is NodePath<t.ArrayTypeAnnotation>;\n  assertArrowFunctionExpression(\n    opts?: object,\n  ): asserts this is NodePath<t.ArrowFunctionExpression>;\n  assertAssignmentExpression(\n    opts?: object,\n  ): asserts this is NodePath<t.AssignmentExpression>;\n  assertAssignmentPattern(\n    opts?: object,\n  ): asserts this is NodePath<t.AssignmentPattern>;\n  assertAwaitExpression(\n    opts?: object,\n  ): asserts this is NodePath<t.AwaitExpression>;\n  assertBigIntLiteral(opts?: object): asserts this is NodePath<t.BigIntLiteral>;\n  assertBinary(opts?: object): asserts this is NodePath<t.Binary>;\n  assertBinaryExpression(\n    opts?: object,\n  ): asserts this is NodePath<t.BinaryExpression>;\n  assertBindExpression(\n    opts?: object,\n  ): asserts this is NodePath<t.BindExpression>;\n  assertBlock(opts?: object): asserts this is NodePath<t.Block>;\n  assertBlockParent(opts?: object): asserts this is NodePath<t.BlockParent>;\n  assertBlockStatement(\n    opts?: object,\n  ): asserts this is NodePath<t.BlockStatement>;\n  assertBooleanLiteral(\n    opts?: object,\n  ): asserts this is NodePath<t.BooleanLiteral>;\n  assertBooleanLiteralTypeAnnotation(\n    opts?: object,\n  ): asserts this is NodePath<t.BooleanLiteralTypeAnnotation>;\n  assertBooleanTypeAnnotation(\n    opts?: object,\n  ): asserts this is NodePath<t.BooleanTypeAnnotation>;\n  assertBreakStatement(\n    opts?: object,\n  ): asserts this is NodePath<t.BreakStatement>;\n  assertCallExpression(\n    opts?: object,\n  ): asserts this is NodePath<t.CallExpression>;\n  assertCatchClause(opts?: object): asserts this is NodePath<t.CatchClause>;\n  assertClass(opts?: object): asserts this is NodePath<t.Class>;\n  assertClassAccessorProperty(\n    opts?: object,\n  ): asserts this is NodePath<t.ClassAccessorProperty>;\n  assertClassBody(opts?: object): asserts this is NodePath<t.ClassBody>;\n  assertClassDeclaration(\n    opts?: object,\n  ): asserts this is NodePath<t.ClassDeclaration>;\n  assertClassExpression(\n    opts?: object,\n  ): asserts this is NodePath<t.ClassExpression>;\n  assertClassImplements(\n    opts?: object,\n  ): asserts this is NodePath<t.ClassImplements>;\n  assertClassMethod(opts?: object): asserts this is NodePath<t.ClassMethod>;\n  assertClassPrivateMethod(\n    opts?: object,\n  ): asserts this is NodePath<t.ClassPrivateMethod>;\n  assertClassPrivateProperty(\n    opts?: object,\n  ): asserts this is NodePath<t.ClassPrivateProperty>;\n  assertClassProperty(opts?: object): asserts this is NodePath<t.ClassProperty>;\n  assertCompletionStatement(\n    opts?: object,\n  ): asserts this is NodePath<t.CompletionStatement>;\n  assertConditional(opts?: object): asserts this is NodePath<t.Conditional>;\n  assertConditionalExpression(\n    opts?: object,\n  ): asserts this is NodePath<t.ConditionalExpression>;\n  assertContinueStatement(\n    opts?: object,\n  ): asserts this is NodePath<t.ContinueStatement>;\n  assertDebuggerStatement(\n    opts?: object,\n  ): asserts this is NodePath<t.DebuggerStatement>;\n  assertDecimalLiteral(\n    opts?: object,\n  ): asserts this is NodePath<t.DecimalLiteral>;\n  assertDeclaration(opts?: object): asserts this is NodePath<t.Declaration>;\n  assertDeclareClass(opts?: object): asserts this is NodePath<t.DeclareClass>;\n  assertDeclareExportAllDeclaration(\n    opts?: object,\n  ): asserts this is NodePath<t.DeclareExportAllDeclaration>;\n  assertDeclareExportDeclaration(\n    opts?: object,\n  ): asserts this is NodePath<t.DeclareExportDeclaration>;\n  assertDeclareFunction(\n    opts?: object,\n  ): asserts this is NodePath<t.DeclareFunction>;\n  assertDeclareInterface(\n    opts?: object,\n  ): asserts this is NodePath<t.DeclareInterface>;\n  assertDeclareModule(opts?: object): asserts this is NodePath<t.DeclareModule>;\n  assertDeclareModuleExports(\n    opts?: object,\n  ): asserts this is NodePath<t.DeclareModuleExports>;\n  assertDeclareOpaqueType(\n    opts?: object,\n  ): asserts this is NodePath<t.DeclareOpaqueType>;\n  assertDeclareTypeAlias(\n    opts?: object,\n  ): asserts this is NodePath<t.DeclareTypeAlias>;\n  assertDeclareVariable(\n    opts?: object,\n  ): asserts this is NodePath<t.DeclareVariable>;\n  assertDeclaredPredicate(\n    opts?: object,\n  ): asserts this is NodePath<t.DeclaredPredicate>;\n  assertDecorator(opts?: object): asserts this is NodePath<t.Decorator>;\n  assertDirective(opts?: object): asserts this is NodePath<t.Directive>;\n  assertDirectiveLiteral(\n    opts?: object,\n  ): asserts this is NodePath<t.DirectiveLiteral>;\n  assertDoExpression(opts?: object): asserts this is NodePath<t.DoExpression>;\n  assertDoWhileStatement(\n    opts?: object,\n  ): asserts this is NodePath<t.DoWhileStatement>;\n  assertEmptyStatement(\n    opts?: object,\n  ): asserts this is NodePath<t.EmptyStatement>;\n  assertEmptyTypeAnnotation(\n    opts?: object,\n  ): asserts this is NodePath<t.EmptyTypeAnnotation>;\n  assertEnumBody(opts?: object): asserts this is NodePath<t.EnumBody>;\n  assertEnumBooleanBody(\n    opts?: object,\n  ): asserts this is NodePath<t.EnumBooleanBody>;\n  assertEnumBooleanMember(\n    opts?: object,\n  ): asserts this is NodePath<t.EnumBooleanMember>;\n  assertEnumDeclaration(\n    opts?: object,\n  ): asserts this is NodePath<t.EnumDeclaration>;\n  assertEnumDefaultedMember(\n    opts?: object,\n  ): asserts this is NodePath<t.EnumDefaultedMember>;\n  assertEnumMember(opts?: object): asserts this is NodePath<t.EnumMember>;\n  assertEnumNumberBody(\n    opts?: object,\n  ): asserts this is NodePath<t.EnumNumberBody>;\n  assertEnumNumberMember(\n    opts?: object,\n  ): asserts this is NodePath<t.EnumNumberMember>;\n  assertEnumStringBody(\n    opts?: object,\n  ): asserts this is NodePath<t.EnumStringBody>;\n  assertEnumStringMember(\n    opts?: object,\n  ): asserts this is NodePath<t.EnumStringMember>;\n  assertEnumSymbolBody(\n    opts?: object,\n  ): asserts this is NodePath<t.EnumSymbolBody>;\n  assertExistsTypeAnnotation(\n    opts?: object,\n  ): asserts this is NodePath<t.ExistsTypeAnnotation>;\n  assertExportAllDeclaration(\n    opts?: object,\n  ): asserts this is NodePath<t.ExportAllDeclaration>;\n  assertExportDeclaration(\n    opts?: object,\n  ): asserts this is NodePath<t.ExportDeclaration>;\n  assertExportDefaultDeclaration(\n    opts?: object,\n  ): asserts this is NodePath<t.ExportDefaultDeclaration>;\n  assertExportDefaultSpecifier(\n    opts?: object,\n  ): asserts this is NodePath<t.ExportDefaultSpecifier>;\n  assertExportNamedDeclaration(\n    opts?: object,\n  ): asserts this is NodePath<t.ExportNamedDeclaration>;\n  assertExportNamespaceSpecifier(\n    opts?: object,\n  ): asserts this is NodePath<t.ExportNamespaceSpecifier>;\n  assertExportSpecifier(\n    opts?: object,\n  ): asserts this is NodePath<t.ExportSpecifier>;\n  assertExpression(opts?: object): asserts this is NodePath<t.Expression>;\n  assertExpressionStatement(\n    opts?: object,\n  ): asserts this is NodePath<t.ExpressionStatement>;\n  assertExpressionWrapper(\n    opts?: object,\n  ): asserts this is NodePath<t.ExpressionWrapper>;\n  assertFile(opts?: object): asserts this is NodePath<t.File>;\n  assertFlow(opts?: object): asserts this is NodePath<t.Flow>;\n  assertFlowBaseAnnotation(\n    opts?: object,\n  ): asserts this is NodePath<t.FlowBaseAnnotation>;\n  assertFlowDeclaration(\n    opts?: object,\n  ): asserts this is NodePath<t.FlowDeclaration>;\n  assertFlowPredicate(opts?: object): asserts this is NodePath<t.FlowPredicate>;\n  assertFlowType(opts?: object): asserts this is NodePath<t.FlowType>;\n  assertFor(opts?: object): asserts this is NodePath<t.For>;\n  assertForInStatement(\n    opts?: object,\n  ): asserts this is NodePath<t.ForInStatement>;\n  assertForOfStatement(\n    opts?: object,\n  ): asserts this is NodePath<t.ForOfStatement>;\n  assertForStatement(opts?: object): asserts this is NodePath<t.ForStatement>;\n  assertForXStatement(opts?: object): asserts this is NodePath<t.ForXStatement>;\n  assertFunction(opts?: object): asserts this is NodePath<t.Function>;\n  assertFunctionDeclaration(\n    opts?: object,\n  ): asserts this is NodePath<t.FunctionDeclaration>;\n  assertFunctionExpression(\n    opts?: object,\n  ): asserts this is NodePath<t.FunctionExpression>;\n  assertFunctionParent(\n    opts?: object,\n  ): asserts this is NodePath<t.FunctionParent>;\n  assertFunctionTypeAnnotation(\n    opts?: object,\n  ): asserts this is NodePath<t.FunctionTypeAnnotation>;\n  assertFunctionTypeParam(\n    opts?: object,\n  ): asserts this is NodePath<t.FunctionTypeParam>;\n  assertGenericTypeAnnotation(\n    opts?: object,\n  ): asserts this is NodePath<t.GenericTypeAnnotation>;\n  assertIdentifier(opts?: object): asserts this is NodePath<t.Identifier>;\n  assertIfStatement(opts?: object): asserts this is NodePath<t.IfStatement>;\n  assertImmutable(opts?: object): asserts this is NodePath<t.Immutable>;\n  assertImport(opts?: object): asserts this is NodePath<t.Import>;\n  assertImportAttribute(\n    opts?: object,\n  ): asserts this is NodePath<t.ImportAttribute>;\n  assertImportDeclaration(\n    opts?: object,\n  ): asserts this is NodePath<t.ImportDeclaration>;\n  assertImportDefaultSpecifier(\n    opts?: object,\n  ): asserts this is NodePath<t.ImportDefaultSpecifier>;\n  assertImportNamespaceSpecifier(\n    opts?: object,\n  ): asserts this is NodePath<t.ImportNamespaceSpecifier>;\n  assertImportSpecifier(\n    opts?: object,\n  ): asserts this is NodePath<t.ImportSpecifier>;\n  assertIndexedAccessType(\n    opts?: object,\n  ): asserts this is NodePath<t.IndexedAccessType>;\n  assertInferredPredicate(\n    opts?: object,\n  ): asserts this is NodePath<t.InferredPredicate>;\n  assertInterfaceDeclaration(\n    opts?: object,\n  ): asserts this is NodePath<t.InterfaceDeclaration>;\n  assertInterfaceExtends(\n    opts?: object,\n  ): asserts this is NodePath<t.InterfaceExtends>;\n  assertInterfaceTypeAnnotation(\n    opts?: object,\n  ): asserts this is NodePath<t.InterfaceTypeAnnotation>;\n  assertInterpreterDirective(\n    opts?: object,\n  ): asserts this is NodePath<t.InterpreterDirective>;\n  assertIntersectionTypeAnnotation(\n    opts?: object,\n  ): asserts this is NodePath<t.IntersectionTypeAnnotation>;\n  assertJSX(opts?: object): asserts this is NodePath<t.JSX>;\n  assertJSXAttribute(opts?: object): asserts this is NodePath<t.JSXAttribute>;\n  assertJSXClosingElement(\n    opts?: object,\n  ): asserts this is NodePath<t.JSXClosingElement>;\n  assertJSXClosingFragment(\n    opts?: object,\n  ): asserts this is NodePath<t.JSXClosingFragment>;\n  assertJSXElement(opts?: object): asserts this is NodePath<t.JSXElement>;\n  assertJSXEmptyExpression(\n    opts?: object,\n  ): asserts this is NodePath<t.JSXEmptyExpression>;\n  assertJSXExpressionContainer(\n    opts?: object,\n  ): asserts this is NodePath<t.JSXExpressionContainer>;\n  assertJSXFragment(opts?: object): asserts this is NodePath<t.JSXFragment>;\n  assertJSXIdentifier(opts?: object): asserts this is NodePath<t.JSXIdentifier>;\n  assertJSXMemberExpression(\n    opts?: object,\n  ): asserts this is NodePath<t.JSXMemberExpression>;\n  assertJSXNamespacedName(\n    opts?: object,\n  ): asserts this is NodePath<t.JSXNamespacedName>;\n  assertJSXOpeningElement(\n    opts?: object,\n  ): asserts this is NodePath<t.JSXOpeningElement>;\n  assertJSXOpeningFragment(\n    opts?: object,\n  ): asserts this 