open Wonka_types;
open Wonka_helpers;

type bufferStateT('a) = {
  mutable buffer: Rebel.MutableQueue.t('a),
  mutable sourceTalkback: (. talkbackT) => unit,
  mutable notifierTalkback: (. talkbackT) => unit,
  mutable pulled: bool,
  mutable ended: bool,
};

[@genType]
let buffer = (notifier: sourceT('a)): operatorT('b, array('b)) =>
  curry(source =>
    curry(sink => {
      let state = {
        buffer: Rebel.MutableQueue.make(),
        sourceTalkback: talkbackPlaceholder,
        notifierTalkback: talkbackPlaceholder,
        pulled: false,
        ended: false,
      };

      source((. signal) => {
        switch (signal) {
        | Start(tb) =>
          state.sourceTalkback = tb;

          notifier((. signal) => {
            switch (signal) {
            | Start(tb) => state.notifierTalkback = tb
            | Push(_) when !state.ended =>
              if (Rebel.MutableQueue.size(state.buffer) > 0) {
                let buffer = state.buffer;
                state.buffer = Rebel.MutableQueue.make();
                sink(. Push(Rebel.MutableQueue.toArray(buffer)));
              }
            | Push(_) => ()
            | End when !state.ended =>
              state.ended = true;
              state.sourceTalkback(. Close);
              if (Rebel.MutableQueue.size(state.buffer) > 0) {
                sink(. Push(Rebel.MutableQueue.toArray(state.buffer)));
              };
              sink(. End);
            | End => ()
            };
            ();
          });
        | Push(value) when !state.ended =>
          Rebel.MutableQueue.add(state.buffer, value);
          if (!state.pulled) {
            state.pulled = true;
            state.sourceTalkback(. Pull);
            state.notifierTalkback(. Pull);
          } else {
            state.pulled = false;
          };
        | Push(_) => ()
        | End when !state.ended =>
          state.ended = true;
          state.notifierTalkback(. Close);
          if (Rebel.MutableQueue.size(state.buffer) > 0) {
            sink(. Push(Rebel.MutableQueue.toArray(state.buffer)));
          };
          sink(. End);
        | End => ()
        };
        ();
      });

      sink(.
        Start(
          (. signal) =>
            if (!state.ended) {
              switch (signal) {
              | Close =>
                state.ended = true;
                state.sourceTalkback(. Close);
                state.notifierTalkback(. Close);
              | Pull when !state.pulled =>
                state.pulled = true;
                state.sourceTalkback(. Pull);
                state.notifierTalkback(. Pull);
              | Pull => ()
              };
            },
        ),
      );
    })
  );

type combineStateT('a, 'b) = {
  mutable talkbackA: (. talkbackT) => unit,
  mutable talkbackB: (. talkbackT) => unit,
  mutable lastValA: option('a),
  mutable lastValB: option('b),
  mutable gotSignal: bool,
  mutable endCounter: int,
  mutable ended: bool,
};

[@genType]
let combine =
    (sourceA: sourceT('a), sourceB: sourceT('b)): sourceT(('a, 'b)) =>
  curry(sink => {
    let state = {
      talkbackA: talkbackPlaceholder,
      talkbackB: talkbackPlaceholder,
      lastValA: None,
      lastValB: None,
      gotSignal: false,
      endCounter: 0,
      ended: false,
    };

    sourceA((. signal) =>
      switch (signal, state.lastValB) {
      | (Start(tb), _) => state.talkbackA = tb
      | (Push(a), None) =>
        state.lastValA = Some(a);
        if (!state.gotSignal) {
          state.talkbackB(. Pull);
        } else {
          state.gotSignal = false;
        };
      | (Push(a), Some(b)) when !state.ended =>
        state.lastValA = Some(a);
        state.gotSignal = false;
        sink(. Push((a, b)));
      | (End, _) when state.endCounter < 1 =>
        state.endCounter = state.endCounter + 1
      | (End, _) when !state.ended =>
        state.ended = true;
        sink(. End);
      | _ => ()
      }
    );

    sourceB((. signal) =>
      switch (signal, state.lastValA) {
      | (Start(tb), _) => state.talkbackB = tb
      | (Push(b), None) =>
        state.lastValB = Some(b);
        if (!state.gotSignal) {
          state.talkbackA(. Pull);
        } else {
          state.gotSignal = false;
        };
      | (Push(b), Some(a)) when !state.ended =>
        state.lastValB = Some(b);
        state.gotSignal = false;
        sink(. Push((a, b)));
      | (End, _) when state.endCounter < 1 =>
        state.endCounter = state.endCounter + 1
      | (End, _) when !state.ended =>
        state.ended = true;
        sink(. End);
      | _ => ()
      }
    );

    sink(.
      Start(
        (. signal) =>
          if (!state.ended) {
            switch (signal) {
            | Close =>
              state.ended = true;
              state.talkbackA(. Close);
              state.talkbackB(. Close);
            | Pull when !state.gotSignal =>
              state.gotSignal = true;
              state.talkbackA(. signal);
              state.talkbackB(. signal);
            | Pull => ()
            };
          },
      ),
    );
  });

type concatMapStateT('a) = {
  inputQueue: Rebel.MutableQueue.t('a),
  mutable outerTalkback: (. talkbackT) => unit,
  mutable outerPulled: bool,
  mutable innerTalkback: (. talkbackT) => unit,
  mutable innerActive: bool,
  mutable innerPulled: bool,
  mutable ended: bool,
};

[@genType]
let concatMap = (f: (. 'a) => sourceT('b)): operatorT('a, 'b) =>
  curry(source =>
    curry(sink => {
      let state: concatMapStateT('a) = {
        inputQueue: Rebel.MutableQueue.make(),
        outerTalkback: talkbackPlaceholder,
        outerPulled: false,
        innerTalkback: talkbackPlaceholder,
        innerActive: false,
        innerPulled: false,
        ended: false,
      };

      let rec applyInnerSource = innerSource => {
        state.innerActive = true;
        innerSource((. signal) => {
          switch (signal) {
          | Start(tb) =>
            state.innerTalkback = tb;
            state.innerPulled = false;
            tb(. Pull);
          | Push(_) when state.innerActive =>
            sink(. signal);
            if (!state.innerPulled) {
              state.innerTalkback(. Pull);
            } else {
              state.innerPulled = false;
            };
          | Push(_) => ()
          | End when state.innerActive =>
            state.innerActive = false;
            switch (Rebel.MutableQueue.pop(state.inputQueue)) {
            | Some(input) => applyInnerSource(f(. input))
            | None when state.ended => sink(. End)
            | None when !state.outerPulled =>
              state.outerPulled = true;
              state.outerTalkback(. Pull);
            | None => ()
            };
          | End => ()
          };
          ();
        });
        ();
      };

      source((. signal) => {
        switch (signal) {
        | Start(tb) => state.outerTalkback = tb
        | Push(x) when !state.ended =>
          state.outerPulled = false;
          if (state.innerActive) {
            Rebel.MutableQueue.add(state.inputQueue, x);
          } else {
            applyInnerSource(f(. x));
          };
        | Push(_) => ()
        | End when !state.ended =>
          state.ended = true;
          if (!state.innerActive
              && Rebel.MutableQueue.isEmpty(state.inputQueue)) {
            sink(. End);
          };
        | End => ()
        };
        ();
      });

      sink(.
        Start(
          (. signal) =>
            switch (signal) {
            | Pull =>
              if (!state.ended && !state.outerPulled) {
                state.outerPulled = true;
                state.outerTalkback(. Pull);
              };
              if (state.innerActive && !state.innerPulled) {
                state.innerPulled = true;
                state.innerTalkback(. Pull);
              };
            | Close =>
              if (!state.ended) {
                state.ended = true;
                state.outerTalkback(. Close);
              };
              if (state.innerActive) {
                state.innerActive = false;
                state.innerTalkback(. Close);
              };
            },
        ),
      );
    })
  );

[@genType]
let concatAll = (source: sourceT(sourceT('a))): sourceT('a) =>
  concatMap((. x) => x, source);

[@genType]
let concat = (sources: array(sourceT('a))): sourceT('a) =>
  concatMap((. x) => x, Wonka_sources.fromArray(sources));

[@genType]
let filter = (f: (. 'a) => bool): operatorT('a, 'a) =>
  curry(source =>
    curry(sink => {
      let talkback = ref(talkbackPlaceholder);

      source((. signal) => {
        switch (signal) {
        | Start(tb) =>
          talkback := tb;
          sink(. signal);
        | Push(x) when !f(. x) => talkback^(. Pull)
        | _ => sink(. signal)
        };
        ();
      });
    })
  );

[@genType]
let map = (f: (. 'a) => 'b): operatorT('a, 'b) =>
  curry(source =>
    curry(sink =>
      source((. signal) => {
        sink(.
          /* The signal needs to be recreated for genType to generate
             the correct generics during codegen */
          switch (signal) {
          | Start(x) => Start(x)
          | Push(x) => Push(f(. x))
          | End => End
          },
        )
      })
    )
  );

type mergeMapStateT = {
  mutable outerTalkback: (. talkbackT) => unit,
  mutable outerPulled: bool,
  mutable innerTalkbacks: Rebel.Array.t((. talkbackT) => unit),
  mutable ended: bool,
};

[@genType]
let mergeMap = (f: (. 'a) => sourceT('b)): operatorT('a, 'b) =>
  curry(source =>
    curry(sink => {
      let state: mergeMapStateT = {
        outerTalkback: talkbackPlaceholder,
        outerPulled: false,
        innerTalkbacks: Rebel.Array.makeEmpty(),
        ended: false,
      };

      let applyInnerSource = innerSource => {
        let talkback = ref(talkbackPlaceholder);

        innerSource((. signal) =>
          switch (signal) {
          | Start(tb) =>
            talkback := tb;
            state.innerTalkbacks =
              Rebel.Array.append(state.innerTalkbacks, tb);
            tb(. Pull);
          | Push(x) when Rebel.Array.size(state.innerTalkbacks) !== 0 =>
            sink(. Push(x));
            talkback^(. Pull);
          | Push(_) => ()
          | End when Rebel.Array.size(state.innerTalkbacks) !== 0 =>
            state.innerTalkbacks =
              Rebel.Array.filter(state.innerTalkbacks, x => x !== talkback^);
            let exhausted = Rebel.Array.size(state.innerTalkbacks) === 0;
            if (state.ended && exhausted) {
              sink(. End);
            } else if (!state.outerPulled && exhausted) {
              state.outerPulled = true;
              state.outerTalkback(. Pull);
            };
          | End => ()
          }
        );
      };

      source((. signal) =>
        switch (signal) {
        | Start(tb) => state.outerTalkback = tb
        | Push(x) when !state.ended =>
          state.outerPulled = false;
          applyInnerSource(f(. x));
          if (!state.outerPulled) {
            state.outerPulled = true;
            state.outerTalkback(. Pull);
          };
        | Push(_) => ()
        | End when !state.ended =>
          state.ended = true;
          if (Rebel.Array.size(state.innerTalkbacks) === 0) {
            sink(. End);
          };
        | End => ()
        }
      );

      sink(.
        Start(
          (. signal) =>
            switch (signal) {
            | Close =>
              if (!state.ended) {
                state.ended = true;
                state.outerTalkback(. signal);
              };

              Rebel.Array.forEach(state.innerTalkbacks, tb => tb(. signal));
              state.innerTalkbacks = Rebel.Array.makeEmpty();
            | Pull =>
              if (!state.outerPulled && !state.ended) {
                state.outerPulled = true;
                state.outerTalkback(. Pull);
              } else {
                state.outerPulled = false;
              };

              Rebel.Array.forEach(state.innerTalkbacks, tb => tb(. Pull));
            },
        ),
      );
    })
  );

[@genType]
let merge = (sources: array(sourceT('a))): sourceT('a) =>
  mergeMap((. x) => x, Wonka_sources.fromArray(sources));

[@genType]
let merge